#-- Compile returnStruct.c

make clean; make


#-- Start the debugger session

gdbtui -q bin/returnStruct


# Instrument the code

(gdb) source ../../Debugger-GDB/FABR/gdb.stackdump

(gdb) break main
(gdb) run

(gdb) set_bfp
(gdb) layout asm
(gdb) winheight asm 10


# Single step to instruction 'call ... <inc_x>'
# Use si for several times

(gdb) si

B+  0x4011da <main+29>      movl   $0x11223344,-0x10(%ebp)
    0x4011e1 <main+36>      movl   $0x55667788,-0xc(%ebp)
    0x4011e8 <main+43>      lea    -0x18(%ebp),%eax
    0x4011eb <main+46>      push   -0xc(%ebp)
    0x4011ee <main+49>      push   -0x10(%ebp)
    0x4011f1 <main+52>      push   %eax
  > 0x4011f2 <main+53>      call   0x401189 <inc_x>

# Inspect the stack

(gdb) stack_all32
-----------
0xbffff0d4: 0xbffff0e0 <-- address where to put return value
0xbffff0d8: 0x11223344 <-- x-coord of parameter 1
0xbffff0dc: 0x55667788 <-- y-coord of parameter 1
0xbffff0e0: 0xbffff120 <-- reserved for return value == p2.x
0xbffff0e4: 0xb7fc3678 <-- reserved for return value == p2.y
0xbffff0e8: 0x11223344 <-- p1.x
0xbffff0ec: 0x55667788 <-- p1.y
0xbffff0f0: 0xbffff110
0xbffff0f4: 0xb7e1cff4
0xbffff0f8: 0x00000000 <--- fp 0
-----------

# Step into the function

(gdb) si

In the function inc_x step to assembler code
for the C-instruction 'return r'
using multiple 'ni' commands

# Code for 'return r'
  > 0x4011a8 <inc_x+31>     mov    0x8(%ebp),%ecx
    0x4011ab <inc_x+34>     mov    -0x8(%ebp),%eax
    0x4011ae <inc_x+37>     mov    -0x4(%ebp),%edx
    0x4011b1 <inc_x+40>     mov    %eax,(%ecx)
    0x4011b3 <inc_x+42>     mov    %edx,0x4(%ecx)

# Print addresses of parameters and local vars

# Parameter p
(gdb) p /x &(p.x)
$2 = 0xbffff0d8
(gdb) p /x &(p.y)
$3 = 0xbffff0dc

# local result variable r
(gdb) p /x &(r.x)
$4 = 0xbffff0c4
(gdb) p /x &(r.y)
$5 = 0xbffff0c8

# Inspect the stack

(gdb) stack_all
-----------
0xbffff0bc: 0xbfffffb8
0xbffff0c0: 0xb7fc9550
0xbffff0c4: 0x11223345 <-- p.x
0xbffff0c8: 0x55667788 <-- p.y
0xbffff0cc: 0xbffff0f8 <--- fp 0
0xbffff0d0: 0x004011f7 <- return address
0xbffff0d4: 0xbffff0e0 <- address of return value
0xbffff0d8: 0x11223344 <- p.x
0xbffff0dc: 0x55667788 <- p.y
0xbffff0e0: 0xbffff120 <- return value r.x
0xbffff0e4: 0xb7fc3678 <- return value r.y
0xbffff0e8: 0x11223344 <- p1.x
0xbffff0ec: 0x55667788 <- p2.y
0xbffff0f0: 0xbffff110
0xbffff0f4: 0xb7e1cff4
0xbffff0f8: 0x00000000 <--- fp 1
-----------

# Execute code for C-instruction 'return r'
# using several si commands

(gdb) si

 > 0x4011b6 <inc_x+45>     mov    0x8(%ebp),%eax
   0x4011b9 <inc_x+48>     leave
   0x4011ba <inc_x+49>     ret    $0x4

# Inspect the stack

(gdb) stack_all

-----------
0xbffff0bc: 0xbfffffb8
0xbffff0c0: 0xb7fc9550
0xbffff0c4: 0x11223345 <-- p.x
0xbffff0c8: 0x55667788 <-- p.y
0xbffff0cc: 0xbffff0f8 <--- fp 0
0xbffff0d0: 0x004011f7 <- return address
0xbffff0d4: 0xbffff0e0 <- address of return value
0xbffff0d8: 0x11223344 <- p.x
0xbffff0dc: 0x55667788 <- p.y
0xbffff0e0: 0x11223345 <-- return value r.x == p2.x
0xbffff0e4: 0x55667788 <-- return value r.y == p2.y
0xbffff0e8: 0x11223344 <- p1.x
0xbffff0ec: 0x55667788 <- p2.y
0xbffff0f0: 0xbffff110
0xbffff0f4: 0xb7e1cff4
0xbffff0f8: 0x00000000 <--- fp 1
-----------

# Leave the function inc_x using three 'si' commands

(gdb) si

  > 0x4011f7 <main+58>      add    $0x8,%esp               
    0x4011fa <main+61>      mov    -0x14(%ebp),%edx        
    0x4011fd <main+64>      mov    -0x18(%ebp),%eax

# Print addresses of p2.x and p2.y

(gdb) p /x &p2.x
$6 = 0xbffff0e0
(gdb) p /x &p2.y
$7 = 0xbffff0e4

# Inspect the frame of function main after
# we returned from call to inc_x

-----------
0xbffff0d8: 0x11223344 <-- x-coord of parameter 1
0xbffff0dc: 0x55667788 <-- y-coord of parameter 1
0xbffff0e0: 0x11223345 <-- reserved for return value == p2.x
0xbffff0e4: 0x55667788 <-- reserved for return value == p2.y
0xbffff0e8: 0x11223344 <-- p1.x
0xbffff0ec: 0x55667788 <-- p1.y
0xbffff0f0: 0xbffff110 
0xbffff0f4: 0xb7e1cff4
0xbffff0f8: 0x00000000 <--- fp 0
-----------


